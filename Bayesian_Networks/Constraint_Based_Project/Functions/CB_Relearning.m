function [g_new, tests_num, dag_steps_list] = CB_Relearning(g_prev, curr_data, c_nodes)

%   Input:
%     - g_prev: the dag from the previous time step
%     - curr_data: the data of the current time step 
%     - c_nodes: the nodes that were detected as changed from the previous 
%                time step
%   Output:
%     - g_new: the dag generated by the algorithm for the current time step
%     - tests_num: number of CI tests done during the learning process
%     - dag_steps_list: the intermidiate dags learned after each step


% Step 1 - Keep must stay edges
n = size(curr_data, 2);
dag_steps_list = cell(1, 3);
g_new = zeros(size(g_prev));
nc_changed = (1:1:n);   % Non changed nodes
nc_changed = setdiff(nc_changed, c_nodes);

for i=1:length(nc_changed)
    nc = nc_changed(i);    % Current non changed node
    nc_parents = g_prev(:, nc) == 1;    % Parents of current nc node
    g_new(nc_parents, nc) = 1;    % Keep the edges from parents of nc to nc
end


% Step 2 - Find parents and children of all nodes in the previous bn
pc = cell(1, n);
for i=1:n
    pc{1, i} = neighbors(g_prev, i);
end


% Step 3 - Erase unneccessary edges from the previous bn
disp('Starting CI tests for previous edge removal:');
g_temp = g_prev - g_new;
[A, B] = find(g_temp == 1);   % Get previous edges to examine: A -> B
sep_sets = cell(n,n);
% max_order is calculated by flooring the mean of max fan in and out
try
    max_order = max(1, floor(0.5 * mean([max(sum(g_prev,1)), max(sum(g_prev,2))])));
    %max_order = max(1, floor(mean([max(sum(g_prev,1)), max(sum(g_prev,2))])));
catch
    max_order = 1;
end

tests_num = 0; % Number of CI tests in every order

% Go over all possible edges to remove
for i=1:length(A)
    a = A(i); 
    b = B(i);
    % Do all CMI tests for edge removal between a and b
    [flag, sep_sets, tests_num] = CMI_tests(a, b, curr_data, sep_sets, max_order, pc, 1, tests_num); 
    
    if flag    % a and b are dependant given every possible sep set
        if ismember(a, c_nodes) && ismember(b, c_nodes)
            % Cannot orient the edge so we put -1 instead of 1
            g_new(a, b) = -1;
            g_new(b, a) = -1;
            fprintf('Keeping unoriented edge %d - %d\n' , a, b);
        else
            g_new(a, b) = 1;    % Learn an edge a -> b
            fprintf('Keeping oriented edge %d -> %d\n' , a, b);
        end
    end
end % End for
dag_steps_list{1, 1} = g_new;   % Save the learned net after step 2
unoriented = g_new(:, :) == -1;  % Make all unoriented edges oriented
dag_steps_list{1, 1}(unoriented) = 1;

% Step 4 - Check adding possible edges
disp('Starting CI tests for possible edge addition:');
unchecked_edges = ones(n, n) - g_prev - g_prev';
unchecked_edges = setdiag(unchecked_edges, 0);
unchecked_edges(:, nc_changed) = 0; % Unchanged nodes cannot add a parent
[A, B] = find(unchecked_edges == 1);
for i=1:length(A)   % Remove from dag one direction of an edge between changed nodes
    if unchecked_edges(A(i),B(i)) == 1 && unchecked_edges(B(i),A(i)) == 1
       unchecked_edges(A(i),B(i)) = 0;
    end
end
[A, B] = find(unchecked_edges == 1);    % All possible edges to add A -> B


% Go over all possible edges to add
for i=1:length(A)
    a = A(i); 
    b = B(i);
    % Do all CMI tests for edge addition between a and b
    [flag, sep_sets, tests_num] = CMI_tests(a, b, curr_data, sep_sets, max_order, pc, 0, tests_num); 
    
    if flag    % a and b are dependant given every possible sep set
        if ismember(a, c_nodes) && ismember(b, c_nodes)
            % Cannot orient the edge so we put -1 instead of 1
            g_new(a, b) = -1;
            g_new(b, a) = -1;
            fprintf('Adding unoriented edge %d - %d\n' , a, b);
        else
            g_temp = (g_new == 1);
            g_temp(a, b) = 1;
            if acyclic(g_temp)  % Edge addition doesn't cause a cyclic dag 
                g_new(a, b) = 1;    % Learn an edge a -> b
                fprintf('Adding oriented edge %d -> %d\n' , a, b);
            end
        end
    end
end % End for


% Step 5 - V-structures orientation
disp('Starting V-structures orientation:');
[A, B] = find(g_new); % a - b / a -> b
%[A, B] = find(g_new == -1); % a - b
% We want to generate all unique triples x,y,z
for i=1:length(A)
  a = A(i);
  b = B(i);
  C = find(g_new(b, :) == -1); % a - b - c / a -> b - c
  C = mysetdiff(C, a);
  for c=C(:)'
    if g_new(a, c) == 0 && ~ismember(b, sep_sets{a, c}) % a and c are not connected and b is not in sepset of a and c
        acyclic_g = (g_new == 1);
        acyclic_g(a, b) = 1; 
        acyclic_g(b, a) = 0;
        acyclic_g(c, b) = 1;
        acyclic_g(b, c) = 0;
        if acyclic(acyclic_g)
            fprintf('Orienting V-structure %d -> %d <- %d\n', a, b, c);
            g_new(a, b) = 1; 
            g_new(b, a) = 0;
            g_new(c, b) = 1; % a -> b <- c
            g_new(b, c) = 0;
        end
    end
  end
end
dag_steps_list{1, 2} = g_new;   % Save the learned net after step 4
unoriented = g_new(:, :) == -1;  % Erase all unoriented edges
dag_steps_list{1, 2}(unoriented) = 0;

% Step 6 - Edge orientation rules
% Rule 1: Serial connections
change = 1;
disp('Starting edge orientation rules:');
while change
    change = 0;
    [A, B] = find(g_new == 1);
    for i=1:length(A)
        a = A(i);
        b = B(i);
        C = find(g_new(b, :) == -1); % a -> b - c
        C = mysetdiff(C, a);
    for c=C(:)'
        if g_new(a, c) == 0 % a and c are not connected
            acyclic_g = (g_new == 1);
            acyclic_g(b, c) = 1; % a -> b -> c
            acyclic_g(c, b) = 0; 
            if acyclic(acyclic_g)
                fprintf('Orienting serial connection %d -> %d -> %d\n', a, b, c);
                g_new(b, c) = 1; % a -> b -> c
                g_new(c, b) = 0; 
                change = 1;
            end
        end
    end
    end

%%%% No need? We take care of it in the V-structures step
% Rule 2: No cycles
% if a - b and there is a directed path between a and b, than a -> b
%[A, B] = find(g_new == -1);
%g_temp = (g_new == 1); % get dag of only directed edges
%g_reach = reachability_graph(g_temp); % get all directed paths in the dag
%for i=1:length(A)
%  a = A(i);
%  b = B(i);
%  if g_reach(a, b) % there is a directed path from a to b
%    g_new(a, b) = 1; % a -> b
%    g_new(b, a) = 0; 
%    % update the paths in the graph - I don't think it's needed
%    % g_temp(a, b) = 1; 
%    % g_reach = reachability_graph(g_temp);
%  end
%end

% Rule 3 - No more V-Structures allowed
% if a - b and c -> b and there is another path such that a - d and d -> b
% and if c and d are non adjacent, then a -> b (other way around will
% create a V-Structure in node a).
    [A,B] = find(g_new == -1); % a - b
    for i=1:length(A)
        a = A(i); 
        b = B(i);
        C = find((g_new(a,:) == -1) & (g_new(:,b) == 1)');
        % C contains nodes c s.t. a - c -> b
        G2 = setdiag(g_new(C, C), 1);
        if any(G2(:) == 0) % there are 2 different non adjacent elements of C
            fprintf('Orienting edge %d -> %d\n', a, b);
            g_new(a, b) = 1; % a -> b
            g_new(b, a) = 0;
            change = 1;
        end
    end
end
dag_steps_list{1, 3} = g_new;   % Save the learned net after step 5
unoriented = g_new(:, :) == -1;  % Erase all unoriented edges
dag_steps_list{1, 3}(unoriented) = 0;

% Step 7 - BDeU score for all possible graphs 
% Create all possible graphs by orienting all still unoriented edges and
% score all the created graphs - choose the one with the best BDeU score.
disp('Starting BDeu scoring for final orientation:');
[A, B] = find(g_new == -1);
for i=1:length(A)
    if g_new(A(i), B(i)) == -1  % One direction as 0 and keep 1 undirected
        g_new(B(i), A(i)) = 0;
    end
end

[A, B] = find(g_new == -1); % Get all undirected edges
node_size = max(curr_data);
Num_edges = length(A);
g_possible = {};    % All possible graphs
bdeus = [];     % An array with all possible graphs' scores
place = 1;
options = dec2bin(0:2^Num_edges-1) - '0';   % 0/1 for all undirected edges in every option

if length(options) > 1  % There is at least one undirected edge
    fprintf('Number of graphs to score is: %d\n', length(options));
    for i=1:length(options) % Loop through the possible graphs
        g_temp = (g_new == 1);  % Graph without the undirected edges
        opt = options(i, :);
        for j=1:length(opt) % Orient every undirected edge in the current graph option
            if opt(j) == 0 
                g_temp(A(j), B(j)) = 1;
            else
                g_temp(B(j), A(j)) = 1;
            end
        end
        if acyclic(g_temp)  % If the graph is acyclic score and place it
            g_possible{place} = g_temp;
            [~, score]  = bdeuFirst(curr_data, g_temp, node_size);
            bdeus = [bdeus, score];
            place = place + 1;
        end 
    end

    max_bdeu = find(bdeus == max(bdeus));   % Find the graph with the best BDeu score
    g_new = cell2mat(g_possible(max_bdeu(1)));
end

end




